1. Design
Model class diagramm: class_diagramm.png

2. Lessons learned
	2.1 Battle Log
	One problem arised, when I tried to return the battle log to each of 
	the participating players, but that was not possible, because only 
	the joining user would call the battle function and in that case, 
	only that user would get the log.
	My solution was to add another function for the first user, 
	which only waits, until the battle is finished and then returns 
	the completed log. I implemented this with the AutoResetEvent
	class, which blocks a single thread (waitHandle.WaitOne()) until it
	is released (waitHandle.Set()).

	2.2 SQL Injection and SQL Parameters
	At first, I wanted to add all values in my SQL commands in the 
	corresponding methods by simply adding it into the string, but then 
	SQL injection would be possible.
	Instead, I used SQL parameters, so SQL injection would not be 
	possible.

	2.3 Repository Pattern
	My first thought was to create a central class, which manages all 
	DML (Data Manipulation Language) Operations and stores all 
	collections for users, packages etc, which could have worked, 
	but then there would only be one single class with countless methods 
	and readability would be much harder.
	Instead, I used the Repository Pattern, with it, each logic and data 
	access is encapsulated from one another and readability of the class 
	is much easier.

3. Unit Testing
For the unit tests I tested all models (view class_diagramm.png) 
with their respective constructors and their public methods.
For each method, which throws exceptions, I split them up into a test 
with no error and tests with errors (for each error another test). 
Furthermore, I wrote multiple test cases for each test, so that all 
possible code paths are covered.

	3.1 Method names with no exception
	The basic structure of my test names is as follows: testMethod or testMethod_explanation. 
	For the explanation, I either wrote the expected result 
	(f.e. testGetUserData_plain and testGetUserData_json) or the expected behaviour 
	(f.e. testCompareAllRules_noCalculation and testCompareAllRules_withCalculation)

	3.2 Method names with exception
	If the method throws an error, I designed additional test cases, 
	which I named testMethod_throwsExcpetion or testMethod_throwsExcpetionExplanation.
	For the explanation, I simply wrote the reason why the error should be thrown
	(f.e. testConfigureDeck_throwsExceptionInvalidCard).

4. Unique Feature - Friends
As a mandatory unqiue feature, I added a the functionality of friends. 
I added a table "friends" into the database, which consists of two columns 
with the IDs of the befriended users. 
At the server itself, I added a list of Guids to the user class, 
which stores the IDs of the befriended users. 

	4.1 Add Friends	
	The first feature is the posibility to add friends. To add a user as a friend, 
	send the request POST /friends with the username of the friend as a payload, 
	the IDs of the users will be added to the database and to the Guid lists.

	4.2 Show List of Friends
	With the request GET /friends, the server returns a list of the data, 
	either json or plain format, of all your friends. 
	The data contains the ID, username, alternative name, bio, image, 
	coins, the stats and also the IDs of their friends.

	4.3 Battle Friends
	Users can join specific battles with the request POST /battles/{username}. 
	This only works if the user, which started the battle, 
	is befriended with the joining user.

	4.4 Remove Friends
	With the request DELETE /friends and the username as the payload, 
	the users will no longer be befriended. The relationship in the database and 
	also the IDs in the coresponding lists will be deleted. 
	
5. Tracked Time: tracked_time.pdf

6. Link to Git: https://github.com/BernhardJakobMatthiasWeidinger/MonsterTradingCardsGame.git